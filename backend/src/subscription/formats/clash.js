const yaml = require('js-yaml');

class ClashFormat {
  getProxyNetwork(inbound) {
    if (inbound.network === 'XHTTP' || inbound.network === 'HTTPUPGRADE') {
      // Most Clash clients do not support xhttp directly.
      // Fallback to ws semantics for better compatibility.
      return 'ws';
    }

    return inbound.network.toLowerCase();
  }

  generate(user, inbounds, options = {}) {
    const branding = options.branding || {};
    const proxies = [];
    const proxyNames = [];

    for (const userInbound of inbounds) {
      const inbound = userInbound.inbound;

      if (!userInbound.enabled || !inbound.enabled) {
        continue;
      }

      const proxy = this.buildProxy(user, inbound);
      if (proxy) {
        proxies.push(proxy);
        proxyNames.push(proxy.name);
      }
    }

    if (proxies.length === 0) {
      throw new Error('No active proxies found');
    }

    const config = {
      profile: {
        name: branding.clashProfileName || branding.appName || 'One-UI',
        'update-interval': 24
      },
      'mixed-port': 7890,
      'allow-lan': false,
      'bind-address': '*',
      mode: 'rule',
      'log-level': 'info',
      ipv6: true,
      'external-controller': '127.0.0.1:9090',
      dns: {
        enable: true,
        ipv6: false,
        'enhanced-mode': 'fake-ip',
        'fake-ip-range': '198.18.0.1/16',
        nameserver: ['223.5.5.5', '119.29.29.29'],
        fallback: ['https://1.1.1.1/dns-query', 'https://8.8.8.8/dns-query'],
        'fallback-filter': {
          geoip: true,
          'geoip-code': 'CN'
        }
      },
      proxies,
      'proxy-groups': [
        {
          name: 'Proxy',
          type: 'select',
          proxies: ['Auto', ...proxyNames, 'DIRECT']
        },
        {
          name: 'Auto',
          type: 'url-test',
          proxies: proxyNames,
          url: 'https://www.gstatic.com/generate_204',
          interval: 300,
          tolerance: 50
        },
        {
          name: 'Direct',
          type: 'select',
          proxies: ['DIRECT', 'Proxy']
        },
        {
          name: 'Reject',
          type: 'select',
          proxies: ['REJECT', 'DIRECT']
        }
      ],
      rules: [
        'DOMAIN-SUFFIX,local,Direct',
        'IP-CIDR,127.0.0.0/8,Direct',
        'IP-CIDR,172.16.0.0/12,Direct',
        'IP-CIDR,192.168.0.0/16,Direct',
        'IP-CIDR,10.0.0.0/8,Direct',
        'DOMAIN-SUFFIX,googlesyndication.com,Reject',
        'DOMAIN-SUFFIX,googleadservices.com,Reject',
        'GEOIP,CN,Direct',
        'MATCH,Proxy'
      ]
    };

    const headerLines = [
      `# Generated by ${branding.appName || 'One-UI'}`,
      branding.supportUrl ? `# Support: ${branding.supportUrl}` : '',
      branding.customFooter ? `# ${branding.customFooter}` : ''
    ].filter(Boolean);

    return `${headerLines.join('\n')}\n${yaml.dump(config, { lineWidth: -1 })}`;
  }

  buildProxy(user, inbound) {
    const name = `${inbound.protocol}-${inbound.remark || inbound.port}`;
    const network = this.getProxyNetwork(inbound);
    const base = {
      name,
      server: inbound.serverAddress,
      port: inbound.port
    };

    switch (inbound.protocol) {
      case 'VLESS':
        return {
          ...base,
          type: 'vless',
          uuid: user.uuid,
          tls: inbound.security === 'TLS',
          'skip-cert-verify': false,
          servername: inbound.serverName,
          network,
          udp: true,
          flow: inbound.flow || '',
          ...((inbound.network === 'WS' || inbound.network === 'XHTTP' || inbound.network === 'HTTPUPGRADE') && {
            'ws-opts': {
              path: inbound.wsPath || '/',
              headers: { Host: inbound.wsHost || inbound.serverName }
            }
          }),
          ...(inbound.network === 'GRPC' && {
            'grpc-opts': {
              'grpc-service-name': inbound.grpcServiceName
            }
          })
        };
      case 'VMESS':
        return {
          ...base,
          type: 'vmess',
          uuid: user.uuid,
          alterId: 0,
          cipher: 'auto',
          tls: inbound.security === 'TLS',
          'skip-cert-verify': false,
          servername: inbound.serverName,
          network,
          udp: true,
          ...((inbound.network === 'WS' || inbound.network === 'XHTTP' || inbound.network === 'HTTPUPGRADE') && {
            'ws-opts': {
              path: inbound.wsPath || '/',
              headers: { Host: inbound.wsHost || inbound.serverName }
            }
          }),
          ...(inbound.network === 'GRPC' && {
            'grpc-opts': {
              'grpc-service-name': inbound.grpcServiceName
            }
          })
        };
      case 'TROJAN':
        return {
          ...base,
          type: 'trojan',
          password: user.password,
          sni: inbound.serverName,
          'skip-cert-verify': false,
          udp: true,
          network,
          ...((inbound.network === 'WS' || inbound.network === 'XHTTP' || inbound.network === 'HTTPUPGRADE') && {
            'ws-opts': {
              path: inbound.wsPath || '/',
              headers: { Host: inbound.wsHost || inbound.serverName }
            }
          }),
          ...(inbound.network === 'GRPC' && {
            'grpc-opts': {
              'grpc-service-name': inbound.grpcServiceName
            }
          })
        };
      case 'SHADOWSOCKS':
        return {
          ...base,
          type: 'ss',
          cipher: inbound.cipher || 'chacha20-ietf-poly1305',
          password: user.password,
          udp: true
        };
      case 'SOCKS':
        return {
          ...base,
          type: 'socks5',
          username: user.email,
          password: user.password,
          udp: true
        };
      case 'HTTP':
        return {
          ...base,
          type: 'http',
          username: user.email,
          password: user.password,
          tls: inbound.security === 'TLS',
          'skip-cert-verify': false
        };
      default:
        return null;
    }
  }
}

module.exports = new ClashFormat();
